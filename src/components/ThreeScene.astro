---
---
<div id="three-container" class="w-full h-full min-h-[400px] opacity-80 mix-blend-screen transition-opacity duration-1000"></div>

<script>
  import * as THREE from 'three';

  const container = document.getElementById('three-container');
  
  if (container) {
    // Scene Setup
    const scene = new THREE.Scene();
    
    // Camera
    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.z = 15;

    // Renderer
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // Particles (Neurons)
    const geometry = new THREE.BufferGeometry();
    const count = 300;
    const positions = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);

    for (let i = 0; i < count; i++) {
        // Create a spherical distribution
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        const r = 8 + (Math.random() * 2); // Radius variation

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        // Colors (Cyan and Purple)
        const color = new THREE.Color();
        color.setHSL(Math.random(), 1.0, 0.5);
        if (Math.random() > 0.5) {
            color.setStyle('#00f3ff'); // Cyan
        } else {
             color.setStyle('#7000ff'); // Purple
        }
        
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.2,
        vertexColors: true,
        transparent: true,
        opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // Connections (Synapses)
    const lineMaterial = new THREE.LineBasicMaterial({
        color: 0x00f3ff,
        transparent: true,
        opacity: 0.15
    });
    
    // We update lines dynamically in the loop or use a static set of lines for performance
    // For a "brain" look, let's connect close particles
    const lineGeometry = new THREE.BufferGeometry();
    // Pre-calculate some connections
    const linePositions = [];
    const connectDistance = 2.5;

    for (let i = 0; i < count; i++) {
        for (let j = i + 1; j < count; j++) {
            const dx = positions[i*3] - positions[j*3];
            const dy = positions[i*3+1] - positions[j*3+1];
            const dz = positions[i*3+2] - positions[j*3+2];
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

            if (dist < connectDistance) {
                linePositions.push(
                    positions[i*3], positions[i*3+1], positions[i*3+2],
                    positions[j*3], positions[j*3+1], positions[j*3+2]
                );
            }
        }
    }
    
    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
    const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
    scene.add(lines);
    
    // Interaction
    let mouseX = 0;
    let mouseY = 0;
    let targetRotationX = 0;
    let targetRotationY = 0;

    const windowHalfX = window.innerWidth / 2;
    const windowHalfY = window.innerHeight / 2;

    document.addEventListener('mousemove', onDocumentMouseMove);

    function onDocumentMouseMove(event) {
        mouseX = (event.clientX - windowHalfX) * 0.001;
        mouseY = (event.clientY - windowHalfY) * 0.001;
    }

    // Animation Loop
    const animate = () => {
        requestAnimationFrame(animate);

        targetRotationY = mouseX * 2;
        targetRotationX = mouseY * 2;

        particles.rotation.y += 0.002 + (targetRotationY - particles.rotation.y) * 0.05;
        particles.rotation.x += 0.001 + (targetRotationX - particles.rotation.x) * 0.05;

        lines.rotation.y = particles.rotation.y;
        lines.rotation.x = particles.rotation.x;

        // Pulse effect
        const time = Date.now() * 0.001;
        material.size = 0.2 + Math.sin(time) * 0.05;

        renderer.render(scene, camera);
    };

    animate();

    // Resize Handler
    window.addEventListener('resize', () => {
        if (!container) return;
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });
  }
</script>
